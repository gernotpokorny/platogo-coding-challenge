import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

// api
import { getTicket, payTicket } from './parkingGarageAPI';

// types
import { RootState, AppThunk } from '../../app/store';
import { SetNonNullable } from 'type-fest';

// utils
import { calculateTicketPrice, getFormattedPaymentDate } from './ParkingGarage.utils';

const PARKING_CAPACITY = 54;

export enum PaymentMethod {
	CREDIT_CARD = 'CREDIT_CARD',
	DEBIT_CARD = 'DEBIT_CARD',
	CASH = 'CASH',
}

export type BarCode = string;

interface Payment {
	paymentDate: number;
	paymentMethod: PaymentMethod;
}

export interface Ticket {
	barCode: BarCode;
	dateOfIssuance: number;
	payment?: Payment;
}

export interface ParkingSpace {
	spaceNumber: number;
	ticket: Ticket | null;
}

export interface ParkingGarageState {
	parkingSpaces: ParkingSpace[];
	currentlyIssuedTickets: Record<BarCode, Ticket>;
	status: 'idle' | 'loading' | 'failed';
}

export const initialState: ParkingGarageState = {
	parkingSpaces: [...Array(PARKING_CAPACITY)].map((_, index: number) => ({
		spaceNumber: index,
		ticket: null,
	})),
	currentlyIssuedTickets: {},
	status: 'idle',
};

export const ParkingGarageSlice = createSlice({
	name: 'parkingGarage',
	initialState,
	// The `reducers` field lets us define reducers and generate associated actions
	reducers: {},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	extraReducers: (builder) => {
		builder
			.addCase(getTicketAsync.fulfilled, (state, action) => {
				const ticket = action.payload;
				state.status = 'idle';
				state.currentlyIssuedTickets[ticket.barCode] = ticket;
			})
			.addCase(payTicketAsync.fulfilled, (state, action) => {
				const ticket = action.payload;
				state.status = 'idle';
				state.currentlyIssuedTickets[ticket.barCode] = ticket;
			})
			.addCase(parkAsync.fulfilled, (state, action) => {
				const { spaceNumber, ticket } = action.payload;
				state.status = 'idle';
				state.parkingSpaces[spaceNumber].ticket = ticket;
			})
			.addCase(leaveAsync.fulfilled, (state, action) => {
				const spaceNumber = action.payload;
				state.status = 'idle';
				state.parkingSpaces[spaceNumber].ticket = null;
			})
	},
});

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.ParkingGarage.value)`
export const selectParkingSpaces = (state: RootState) => state.parkingGarage.parkingSpaces;
export const selectTicketWithBarCode = (barCode: BarCode) => (state: RootState) =>
	state.parkingGarage.currentlyIssuedTickets[barCode]
		? state.parkingGarage.currentlyIssuedTickets[barCode]
		: null;
export const selectTicketOfParkingBox = (spaceNumber: number) => (state: RootState) =>
	state.parkingGarage.parkingSpaces[spaceNumber].ticket
		? state.parkingGarage.parkingSpaces[spaceNumber].ticket
		: null;

export const getTicketAsync = createAsyncThunk<
	Ticket,
	undefined,
	{ state: RootState }
>(
	'parkingGarage/getTicket',
	async (_, { getState, dispatch }) => {
		const response = await getTicket();
		if (response.ok) {
			return response.ticket;
		}
		else {
			throw new Error(response.statusText);
		}
	}
);

export const parkAsync = createAsyncThunk<
	SetNonNullable<ParkingSpace, 'ticket'>,
	{ spaceNumber: number },
	{ state: RootState }
>(
	'parkingGarage/park',
	async ({ spaceNumber }, { getState, dispatch }) => {
		const ticket = await dispatch(getTicketAsync()).unwrap();
		return {
			spaceNumber,
			ticket: {
				barCode: ticket.barCode,
				dateOfIssuance: Date.now(),
			},
		};
	}
);

export const payTicketAsync = createAsyncThunk<
	Ticket,
	{ barCode: BarCode; paymentMethod: PaymentMethod },
	{ state: RootState }
>(
	'parkingGarage/payTicket',
	async ({ barCode, paymentMethod }, { getState }) => {
		const ticket = selectTicketWithBarCode(barCode)(getState());
		if (ticket) {
			const response = await payTicket(ticket, paymentMethod);
			if (response.ok) {
				return {
					...ticket,
					payment: {
						paymentMethod,
						paymentDate: Date.now(),
					},
				}
			}
			else {
				throw new Error(response.statusText);
			}
		}
		else {
			throw new Error('Ticket cannot be found!');
		}
	}
);

export const leaveAsync = createAsyncThunk<
	number,
	{ spaceNumber: number; paymentMethod: PaymentMethod },
	{ state: RootState }
>(
	'parkingGarage/leave',
	async ({ spaceNumber, paymentMethod }, { getState, dispatch }) => {
		const ticket = selectTicketOfParkingBox(spaceNumber)(getState());
		if (ticket) {
			const ticketPrice = dispatch(calculatePrice(ticket.barCode));
			console.log('ticketPrice', ticketPrice);
			await dispatch(payTicketAsync({ barCode: ticket.barCode, paymentMethod })).unwrap();
			return spaceNumber;
		}
		else {
			throw new Error('Parking slot is occupied, but has no ticket!');
		}
	}
);

type PaymentReceipt = string[];

interface CalculatePricePaidTicketReturnValue {
	ticketPrice: number;
	paymentReceipt: PaymentReceipt;
}

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
export const calculatePrice = (barCode: BarCode): AppThunk<number | CalculatePricePaidTicketReturnValue | void> =>
	(dispatch, getState) => {
		const ticket = selectTicketWithBarCode(barCode)(getState());
		if (ticket) {
			if (ticket.payment) {
				const issueDate = new Date(ticket.dateOfIssuance);
				const paymentDate = new Date(ticket.payment.paymentDate);
				const ticketPrice = calculateTicketPrice(issueDate, paymentDate);
				return {
					ticketPrice: 0,
					paymentReceipt: [
						`Payed: ${ticketPrice}â‚¬`,
						`Payment date: ${getFormattedPaymentDate(new Date(ticket.payment.paymentDate))}`,
						`Payment method: ${ticket.payment.paymentMethod}`,
					],
				};
			}
			else {
				const issueDate = new Date(ticket.dateOfIssuance);
				const paymentDate = new Date();
				const ticketPrice = calculateTicketPrice(issueDate, paymentDate);
				return ticketPrice;
			}
		}
		else {
			throw new Error('Ticket cannot be found!');
		}
	};

export default ParkingGarageSlice.reducer;
