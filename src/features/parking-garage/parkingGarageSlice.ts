// api
import { getTicket, payTicket, getTicketState, checkoutSuccess } from './parkingGarageAPI';

// types
import { RootState, AppThunk } from '../../app/store';
import { SetNonNullable } from 'type-fest';
import { PayloadAction } from '@reduxjs/toolkit';
import {
	GetTicketResponseSuccess,
	PayTicketResponseSuccess,
	GetTicketStateResponseSuccess,
	CheckoutSuccessResponseSuccess,
} from './parkingGarageAPI';

// utils
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { calculateTicketPrice, getFormattedPaymentDate } from './ParkingGarage.utils';

export const PARKING_CAPACITY = 54;

export enum ErrorCode {
	FULL_PARKING_GARAGE = 'The parking garage is already full, there are no more parking spaces available.'
}

export enum PaymentMethod {
	CREDIT_CARD = 'CREDIT_CARD',
	DEBIT_CARD = 'DEBIT_CARD',
	CASH = 'CASH',
}

export enum TicketState {
	PAID = 'PAID',
	UNPAID = 'UNPAID',
}

export type BarCode = string;

interface Payment {
	paymentDate: number;
	paymentMethod: PaymentMethod;
}

export type PaymentReceipt = string[];

export interface Ticket {
	barCode: BarCode;
	dateOfIssuance: number;
	payments?: Payment[];
	ticketPrice: number;
	paymentReceipt?: PaymentReceipt;
}

export interface ParkingSpace {
	spaceNumber: number;
	barCode: BarCode | null;
	showAre15MinutesPassedSincePaymentMessage: boolean,
}

interface Error {
	message: string;
	name?: string;
	stack?: string;
}

export interface ParkingGarageState {
	parkingSpaces: ParkingSpace[];
	currentlyIssuedTickets: Record<BarCode, Ticket>;
	isGoodByeSnackbarOpen: boolean;
	error: Error | null;
}

export const initialState: ParkingGarageState = {
	parkingSpaces: [...Array(PARKING_CAPACITY)].map((_, index: number) => ({
		spaceNumber: index,
		barCode: null,
		showAre15MinutesPassedSincePaymentMessage: false,
	})),
	currentlyIssuedTickets: {},
	isGoodByeSnackbarOpen: false,
	error: null,
};

export const parkingGarageSlice = createSlice({
	name: 'parkingGarage',
	initialState,
	// The `reducers` field lets us define reducers and generate associated actions
	reducers: {
		setIsGoodByeSnackbarOpen: (state, action: PayloadAction<boolean>) => {
			state.isGoodByeSnackbarOpen = action.payload;
		},
		setError: (state, action: PayloadAction<Error | null>) => {
			state.error = action.payload;
		},
		setShowAre15MinutesPassedSincePaymentMessage: (state, action: PayloadAction<{ spaceNumber: number; value: boolean }>) => {
			const { value, spaceNumber } = action.payload;
			state.parkingSpaces[spaceNumber].showAre15MinutesPassedSincePaymentMessage = value;
		},
		setTicketPrice: (state, action: PayloadAction<{ ticketPrice: number; barCode: string; }>) => {
			const { barCode, ticketPrice } = action.payload;
			state.currentlyIssuedTickets[barCode].ticketPrice = ticketPrice;
		},
		setPaymentReceipt: (state, action: PayloadAction<{ paymentReceipt: PaymentReceipt; barCode: string; }>) => {
			const { barCode, paymentReceipt } = action.payload;
			state.currentlyIssuedTickets[barCode].paymentReceipt = paymentReceipt;
		},
	},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	extraReducers: (builder) => {
		builder
			.addCase(getTicketAsync.fulfilled, (state, action) => {
				const ticket = action.payload;
				state.currentlyIssuedTickets[ticket.barCode] = ticket;
			})
			.addCase(payTicketAsync.fulfilled, (state, action) => {
				const { payment, barCode } = action.payload;
				const ticket = state.currentlyIssuedTickets[barCode];
				if (ticket.payments) {
					ticket.payments.push(payment);

				}
				else {
					ticket.payments = [payment];
				}
			})
			.addCase(parkAsync.fulfilled, (state, action) => {
				if (action.payload !== null) {
					const { spaceNumber, barCode } = action.payload;
					state.parkingSpaces[spaceNumber].barCode = barCode;
				}
			})
			.addCase(leaveAsync.fulfilled, (state, action) => {
				if (action.payload !== null) {
					const { spaceNumber, ticketState, barCode } = action.payload;
					if (ticketState === TicketState.PAID) {
						state.parkingSpaces[spaceNumber].barCode = null;
						delete state.currentlyIssuedTickets[barCode];
					}
				}
			});
	},
});

export const {
	setIsGoodByeSnackbarOpen,
	setError,
	setShowAre15MinutesPassedSincePaymentMessage,
	setTicketPrice,
	setPaymentReceipt,
} = parkingGarageSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.ParkingGarage.value)`
export const selectParkingSpaces = (state: RootState) => state.parkingGarage.parkingSpaces;
export const selectTicketWithBarCode = (barCode: BarCode | null) => (state: RootState) => {
	if (barCode !== null) {
		return state.parkingGarage.currentlyIssuedTickets[barCode]
			? state.parkingGarage.currentlyIssuedTickets[barCode]
			: null;
	}
	else {
		return null;
	}
};
export const selectAmountOfFreeParkingSpaces = (state: RootState) =>
	state.parkingGarage.parkingSpaces.length - Object.keys(state.parkingGarage.currentlyIssuedTickets).length;
export const selectIsGoodByeSnackbarOpen = (state: RootState) => state.parkingGarage.isGoodByeSnackbarOpen;
export const selectError = (state: RootState) => state.parkingGarage.error;

export const getTicketAsync = createAsyncThunk<
	Ticket,
	undefined,
	{ state: RootState }
>(
	'parkingGarage/getTicket',
	async (_, { getState, dispatch }) => {
		const amountOfFreeParkingSpaces = selectAmountOfFreeParkingSpaces(getState());
		if (amountOfFreeParkingSpaces === 0) {
			throw new Error(ErrorCode.FULL_PARKING_GARAGE);
		}
		const response = await getTicket();
		if (response.ok) {
			const data = await response.json();
			return (data as GetTicketResponseSuccess).ticket;
		}
		else {
			throw new Error(response.statusText);
		}
	}
);

export const parkAsync = createAsyncThunk<
	SetNonNullable<ParkingSpace, 'barCode'> | null,
	{ spaceNumber: number; executeWelcomeDialog: () => Promise<boolean>; resetWelcomeDialog: () => void; },
	{ state: RootState }
>(
	'parkingGarage/park',
	async ({ spaceNumber, executeWelcomeDialog, resetWelcomeDialog }, thunkAPI) => {
		if (!await executeWelcomeDialog()) {
			await resetWelcomeDialog();
			return null;
		}
		else {
			await resetWelcomeDialog();
		}
		const ticket = await thunkAPI.dispatch(getTicketAsync()).unwrap();
		return {
			spaceNumber,
			barCode: ticket.barCode,
			showAre15MinutesPassedSincePaymentMessage: false,
		};
	}
);

export const payTicketAsync = createAsyncThunk<
	{ payment: Payment, barCode: BarCode },
	{ barCode: BarCode; paymentMethod: PaymentMethod },
	{ state: RootState }
>(
	'parkingGarage/payTicket',
	async ({ barCode, paymentMethod }, { getState }) => {
		const ticket = selectTicketWithBarCode(barCode)(getState());
		if (ticket) {
			const response = await payTicket(ticket, paymentMethod);
			if (response.ok) {
				const data = await response.json();
				return {
					payment: {
						paymentMethod,
						paymentDate: (data as PayTicketResponseSuccess).paymentDate,
					},
					barCode,
				};
			}
			else {
				throw new Error(response.statusText);
			}
		}
		else {
			throw new Error('Ticket cannot be found!');
		}
	}
);

export const leaveAsync = createAsyncThunk<
	{ spaceNumber: number; ticketState: TicketState; barCode: string; } | null,
	{
		spaceNumber: number;
		paymentMethod: PaymentMethod;
		barCode: string;
		executePayTicketDialog: () => Promise<boolean>;
		resetPayTicketDialog: () => void;
		executePaymentSuccessfulDialog: () => Promise<boolean>;
		resetPaymentSuccessfulDialog: () => void;
		executeGateCheckoutDialog: () => Promise<boolean>;
		resetGateCheckoutDialog: () => void;
		executeNotPayedEnoughDialog: () => Promise<boolean>;
		resetNotPayedEnoughDialog: () => void;
	},
	{ state: RootState }
>(
	'parkingGarage/leave',
	async (
		{
			spaceNumber,
			paymentMethod,
			barCode,
			executePayTicketDialog,
			resetPayTicketDialog,
			executePaymentSuccessfulDialog,
			resetPaymentSuccessfulDialog,
			executeGateCheckoutDialog,
			resetGateCheckoutDialog,
			executeNotPayedEnoughDialog,
			resetNotPayedEnoughDialog,
		},
		{ getState, dispatch }
	) => {
		const ticket = selectTicketWithBarCode(barCode)(getState());
		if (ticket) {
			const ticketState = await dispatch(getTicketStateAsync({ barCode })).unwrap();
			if (ticketState === TicketState.UNPAID && ticket.payments) {
				dispatch(setShowAre15MinutesPassedSincePaymentMessage({ spaceNumber, value: true }));
			}
			else {
				dispatch(setShowAre15MinutesPassedSincePaymentMessage({ spaceNumber, value: false }));
			}
			if (ticketState === TicketState.UNPAID) {
				const price = await dispatch(calculatePriceAsync({ barCode })).unwrap();
				dispatch(setTicketPrice({ ticketPrice: price.ticketPrice, barCode }));
				if (price.paymentReceipt) {
					dispatch(setPaymentReceipt({ paymentReceipt: price.paymentReceipt, barCode }));
				}
				if (!await executePayTicketDialog()) {
					await resetPayTicketDialog();
					return null;
				}
				else {
					await resetPayTicketDialog();
				}
				await dispatch(payTicketAsync({ barCode: barCode, paymentMethod })).unwrap();
				const priceAfterPayment = await dispatch(calculatePriceAsync({ barCode })).unwrap();
				dispatch(setTicketPrice({ ticketPrice: priceAfterPayment.ticketPrice, barCode }));
				if (priceAfterPayment.paymentReceipt) {
					dispatch(setPaymentReceipt({ paymentReceipt: priceAfterPayment.paymentReceipt, barCode }));
				}
				await executePaymentSuccessfulDialog();
				await resetPaymentSuccessfulDialog();
			}
			if (!await executeGateCheckoutDialog()) {
				await resetGateCheckoutDialog();
				return null;
			}
			else {
				await resetGateCheckoutDialog();
			}
			const payedTicket = selectTicketWithBarCode(barCode)(getState());
			if (payedTicket) {
				const ticketStatePayedTicket = await dispatch(getTicketStateAsync({ barCode })).unwrap();
				if (ticketStatePayedTicket === TicketState.PAID) {
					await dispatch(setIsGoodByeSnackbarOpen(true));
					const checkoutSuccessResponse = await checkoutSuccess(payedTicket.barCode);
					if (checkoutSuccessResponse.ok) {
						const checkoutSuccessData = await checkoutSuccessResponse.json();
						if ((checkoutSuccessData as CheckoutSuccessResponseSuccess).success) {
							return { spaceNumber, ticketState: ticketStatePayedTicket, barCode };
						}
						else {
							return null;
						}
					}
					else {
						throw new Error(checkoutSuccessResponse.statusText);
					}
				}
				else {
					await executeNotPayedEnoughDialog();
					await resetNotPayedEnoughDialog();
					return null;
				}

			}
			else {
				throw new Error('Ticket cannot be found!');
			}
		}
		else {
			throw new Error('Ticket cannot be found!');
		}
	}
);

export interface CalculatePricePaidTicketReturnValue {
	ticketPrice: number;
	paymentReceipt?: PaymentReceipt;
}

export const calculatePriceAsync = createAsyncThunk<
	CalculatePricePaidTicketReturnValue,
	{ barCode: string; },
	{ state: RootState }
>(
	'parkingGarage/getTicketState',
	async ({ barCode }, { getState, dispatch }) => {
		const ticket = selectTicketWithBarCode(barCode)(getState());
		if (ticket) {
			const ticketState = await dispatch(getTicketStateAsync({ barCode })).unwrap();
			if (ticket.payments && ticket.payments.length > 0 && ticketState === TicketState.PAID) {
				if (ticket.payments.length === 1) {
					const issueDate = new Date(ticket.dateOfIssuance);
					const currentPayment = ticket.payments[ticket.payments.length - 1];
					const paymentDate = new Date(currentPayment.paymentDate);
					const ticketPrice = calculateTicketPrice(issueDate, paymentDate);
					return {
						ticketPrice: 0,
						paymentReceipt: [
							`Paid: ${ticketPrice}€`,
							`Payment date: ${getFormattedPaymentDate(paymentDate)}`,
							`Payment method: ${currentPayment.paymentMethod}`,
						],
					};
				}
				else {
					const penultimatePaymentDate = new Date(ticket.payments[ticket.payments.length - 2].paymentDate);
					const currentPayment = ticket.payments[ticket.payments.length - 1];
					const paymentDate = new Date(currentPayment.paymentDate);
					const ticketPrice = calculateTicketPrice(penultimatePaymentDate, paymentDate);
					return {
						ticketPrice: 0,
						paymentReceipt: [
							`Paid: ${ticketPrice}€`,
							`Payment date: ${getFormattedPaymentDate(paymentDate)}`,
							`Payment method: ${currentPayment.paymentMethod}`,
						],
					};
				}
			}
			else {
				if (ticket.payments && ticket.payments.length > 0) {
					const lastPayment = ticket.payments[ticket.payments.length - 1];
					const paymentDate = new Date(Date.now()); // Date.now() gets mocked within the test!
					const ticketPrice = calculateTicketPrice(
						new Date(lastPayment.paymentDate),
						paymentDate
					);
					return {
						ticketPrice,
					};
				}
				else {
					const issueDate = new Date(ticket.dateOfIssuance);
					const paymentDate = new Date(Date.now()); // Date.now() gets mocked within the test!
					const ticketPrice = calculateTicketPrice(issueDate, paymentDate);
					return {
						ticketPrice,
					};
				}
			}
		}
		else {
			throw new Error('Ticket cannot be found!');
		}
	}
);

export const getTicketStateAsync = createAsyncThunk<
	TicketState,
	{ barCode: string; },
	{ state: RootState }
>(
	'parkingGarage/getTicketState',
	async ({ barCode }) => {
		const response = await getTicketState(barCode);
		if (response.ok) {
			const data = await response.json();
			return (data as GetTicketStateResponseSuccess).ticketState;
		}
		else {
			throw new Error(response.statusText);
		}
	}
);

export const getFreeSpaces = (): AppThunk<number> =>
	(dispatch, getState) => {
		const amountOfFreeParkingSpaces = selectAmountOfFreeParkingSpaces(getState());
		return amountOfFreeParkingSpaces;
	};

export default parkingGarageSlice.reducer;
